# Build System of `uv.mbt`

The build process of `libuv` inside `uv.mbt` is designed with the following goals:

1. **Zero-configuration**. There is nothing to configure beyond adding the
   module as a dependency.
2. **TinyCC compatible**. Using `tcc` ensures blazing fast test feedback for
   prototyping.
3. **Safety**. No script/command will be run upon/after installation.

To achieve these goals, `uv.mbt` pre-processes all C files of `libuv` so that
they can be compiled and linked without extra command line arguments to the
compiler. However, this only works on the macOS platform, as both Linux and
Windows require `libuv` to be linked against additional libraries to work. As we
work on supporting these two platforms, we might have to compromise some of our
goals above.

## Rationale

There are several ways to build a C library using `moon`:

1. **Pre-build tasks**. This is a generic hook that allows users to run
   arbitrary commands before the building step of `moon`. However, to have the C
   files generated by MoonBit linked against the library built using pre-build
   tasks, the `"moon.pkg.json"` file must be modified to contain link flags that
   tell `moon` to link their artifacts to the built library. Additionally, these
   link flags fail to pass down along the dependency chain, which means end
   users will have to manually specify the link flags. Manual specification is
   not only tedious but also error-prone, and makes it harder for upstream
   libraries to push updates to the build process to users.

2. **Out-sourcing to other build systems**. This method integrates well with
   existing build systems, as you can set the `"cc"` to be `"echo"` to prevent
   `moon` from actually building C files generated by the compiler. However, in
   the future, the MoonBit toolchain `moon` will likely stop emitting C files,
   making this method no longer a good choice for long-term project development.

3. **(New) Post-add tasks**. This is a new hook in `moon` that can run arbitrary
   commands upon dependency installation. This mechanism is promising and will
   potentially solve `uv.mbt`'s linking issues on Linux and Windows, and could
   serve as an entry point for binary distribution and integration with existing
   build systems.

4. **Pre-processing**. This is the approach we are currently using. By handling
   all the complex work ahead of time, this method provides the best user
   experience. However, this method requires the C dependency to be 100% C, as
   only C files can be built by `moon` without specifying any additional flags.

## Implementation

The pre-processing of C files performs the following four operations:

1. Prepend macro definitions to every file.
2. Flatten the source hierarchy.
3. Relocate `#include` directives.
4. Update `moon.pkg.json`.

### Macro Definitions

`libuv` defines different macros for different platforms. For example, on
Windows it defines `WIN32_LEAN_AND_MEAN` and others, while on Unix-like systems
it defines `_FILE_OFFSET_BITS=64`. In the `CMakeLists.txt` file of the `libuv`
library, these flags are specified using command line arguments. However,
different platforms have different command line arguments, and to meet our goal
that `uv.mbt` should be zero-configuration, we have to define these macros in
the source code itself. To do this, we prepend the macro definitions to the top
of each C file:

```c
#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#define _WIN32_WINNT 0x0A00
#define _CRT_DECLARE_NONSTDC_NAMES 0
#else
#define _FILE_OFFSET_BITS 64
#define _LARGEFILE_SOURCE
#endif

#ifdef __APPLE__
#define _DARWIN_UNLIMITED_SELECT 1
#define _DARWIN_USE_64_BIT_INODE 1
#endif

#ifdef __linux__
#define _GNU_SOURCE
#define _POSIX_C_SOURCE 200112
#endif
```

### Flatten Hierarchy

In MoonBit, the path of a package _is_ its relative path to the module.
Therefore, if we were to keep the file hierarchy of `libuv`, we would have to
create multiple packages and reference them in the root package. In most cases,
these packages would be empty except for the C files built as stubs. This would
cause the MoonBit compiler to complain that these packages are not used.

To eliminate these warnings, we flatten the file hierarchy of `libuv`, so that
all source files and headers are placed at the same level inside the root
package. However, there might be two files from different folders that have the
same `basename`. For example, `src/win/internal.h` and `src/unix/internal.h`. To
resolve this name clash, we encode the path of the file by replacing the path
separator `/` with `#` to create a new `basename` for the file:

- `src/win/internal.h` gets renamed to `src#win#internal.h`
- `src/unix/internal.h` gets renamed to `src#unix#internal.h`

However, renaming the files invalidates all the `#include` directives in the
source files. Therefore, we have to relocate the `#include` directives, which is
discussed in the next section.

### Header Relocation

Only the local `#include` directives need to be relocated. We use the following
Python code to match the local `#include` directives:

```python
content = re.sub(r'#(?P<indent>\s*)include "(?P<header>.*?)"', replace, content)
```

After extracting the header name, we perform header lookup against a pre-defined
list of include directories:

1. The directory of the current file.
2. The `include` directory under `libuv`
3. The `src` directory under `libuv`

Once we find the header, we replace the header name with the new, mangled header
name under the flattened hierarchy. For example, if we find
`#include "internal.h"` in `src/unix/async.c`, we will replace it with
`#include "src#unix#internal.h"`.

### Update `moon.pkg.json`

The `moon.pkg.json` file is updated to include all generated C files in the
`"native-stub"` field, so that `moon` will build them. Additionally, it will
update or add a pre-build task so that the developers of `uv.mbt` can have these
files automatically generated when they first run `moon check` inside this
module. The pre-build task will be removed upon publication, so that end users
will not have to run the pre-build task again.
